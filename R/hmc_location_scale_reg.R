#source("R/one_function_model.R")
#source("R/HMC_sim.R")
#source("R/helper_functions.R")

#library(numDeriv)

#' Bayesian inference using Hamiltonian Monte Carlo (HMC) for simple linear regression.
#' @description
#'
#' This function fits a Bayesian linear regression model using HM and returns posterior summaries.
#'
#' @param data A data.frame, list or environment containing the variables specified in the formula.
#' @param stepsize The step size of each iteration of the HMC algorithm.
#'                 Default is 0.00005.
#' @param trajectory_length The number of steps taken by the Hamiltonian dynamics in each iteration of HMC.
#'                          Default is 10.
#' @param chain_length The total number of iterations (samples) to generate in the HMC chain.
#'                     Default is 10000.
#' @param burn_in The number of initial iterations in the MCMC chain to discard before the chain reaches
#'                approximate stationarity. Default is 500.
#' @param thin The thinning interval for the MCMC chain. Every thin-th sample is retained after the
#'             burn-in period to reduce autocorrelation. Default is 1.
#'#' @return An object of class "bayes_hmc_reg" containing posterior summaries:
#'         \item{coefficients}{A list with estimated coefficients (`location` for beta and `scale` for gamma).}
#'         \item{credible_intervals}{A list with 95% credible intervals for coefficients (`coef_loc` for beta and `coef_scale` for gamma).}
#'         \item{fitted.values}{A list with estimated location and scale of the response variable.}
#'         \item{formula}{The formula used in the regression model.}
#'         \item{model_matrix}{The design matrix used in the regression model.}
#'         \item{response}{The response variable used in the regression model.}
#'         \item{n_obs}{The number of observations.}
#'         \item{samples}{Samples generated by the HMC algorithm.}
#' @param formula_y_x
#' @param formula_sigma
#'         \item{acceptance_rate}{Acceptance rate of the HMC algorithm.}
#'
#' @importFrom stats model.matrix model.response rnorm quantile median
#' @importFrom numDeriv grad
#' @examples
#' library(lmls)
#' hmc_simple_reg(y ~ x, data = abdom)
#' @export
hmc_simple_reg <-
  function(formula_y_x,
           formula_sigma,
           data,
           stepsize = 0.00005,
           trajectory_length = 10,
           chain_length = 10000,
           burn_in = 500,
           thin = 1) {
    model_call <- match.call()
    # extract model components
    model_frame <- model.frame(formula_y_x, data)
    Y <- stats::model.response(model_frame)
    X <- stats::model.matrix(formula_y_x, data)
    Z <- stats::model.matrix(formula_sigma, data)
    dim_beta <- ncol(X)
    dim_gamma <- ncol(Z)
    n_data <- length(Y)
    # Initial parameter estimates
    initial_params <-
      c(rep(0, dim_beta), rep(0, dim_gamma)) # Initialize both beta and gamma
    # Use optim to find the MLE
    mle_result <-
      stats::optim(
        initial_params,
        function(beta_gamma, X, Y, Z) neg_log_likelihood(beta_gamma, X, Y, Z, dim_beta, dim_gamma, n_data),
        X = X,
        Y = Y,
        Z = Z,
        method = "BFGS",
        control = list(maxit = 1000)
      )
    beta_gamma_init <- mle_result$par
    beta_gamma <- beta_gamma_init # really needed?
    print(beta_gamma_init)

    hmc <-  build_chain(
      function(beta_gamma) log_likeli(beta_gamma, X, Y, Z, dim_beta, dim_gamma, n_data),
      function(beta_gamma) numDeriv::grad(function(beta_gamma) log_likeli(beta_gamma, X, Y, Z, dim_beta, dim_gamma, n_data), beta_gamma),
      beta_gamma_init,
      stepsize,
      trajectory_length,
      chain_length,
      burn_in,
      thin
    )
    samples <- hmc$samples
    acceptance_rate <- hmc$acceptance_rate # hmc acceptance rate
    # extract hmc chain and compute estimates for beta and gamma
    temp <- estimate_beta_gamma(samples, X, Z)
    # compute credible intervals
    beta_ci <- compute_credible_intervals(temp$beta_samples)
    gamma_ci <- compute_credible_intervals(temp$gamma_samples)
    # estimated location and scale of response
    location_est <- X %*% temp$beta_mean
    scale_est <- scale_est(temp$gamma_mean, Z)
    # calculate raw residuals
    raw_residuals <- Y - location_est
    # number of samples
    n = length(Y)
    # list of results
    results <- structure(list(
      coefficients = list(location = temp$beta_mean, scale = temp$gamma_mean),
      credible_intervals = list(coef_loc = beta_ci, coef_scale = gamma_ci),
      fitted.values = list(location = location_est, scale = scale_est),
      residuals = raw_residuals,
      formula_y_x = formula_y_x,
      formula_sigma = formula_sigma,
      model_matrix = X,
      response = Y,
      n_obs = n,
      samples = list(beta_samples = temp$beta_samples, gamma_samples = temp$gamma_samples),
      acceptance_rate = acceptance_rate,
      call = model_call
    ))
    # assign S3 class "bayes_hmc_reg" to result
    class(results) <- "bayes_hmc_reg"
    # return class object
    return(results)
  }
